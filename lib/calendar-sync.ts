interface StudySession {
  id: number
  title: string
  assignmentId?: number
  taskId?: number
  date: string
  time: string
  duration: number
  type: "study" | "task" | "break"
  priority: "low" | "medium" | "high"
  confidence: number
}

interface SyncResult {
  success: boolean
  syncedCount: number
  failedCount: number
  errors: string[]
  syncedSessions: StudySession[]
}

interface CalendarEvent {
  id: string
  title: string
  description: string
  start: string
  end: string
  location?: string
  reminders?: number[]
}

export class CalendarSyncService {
  private isConnected = true // Simulate Google Calendar connection

  // Simulate Google Calendar API connection check
  async checkConnection(): Promise<boolean> {
    // In a real app, this would check the actual Google Calendar API connection
    return new Promise((resolve) => {
      setTimeout(() => resolve(this.isConnected), 500)
    })
  }

  // Convert study session to calendar event format
  private sessionToCalendarEvent(session: StudySession): CalendarEvent {
    const startDateTime = new Date(`${session.date}T${session.time}:00`)
    const endDateTime = new Date(startDateTime.getTime() + session.duration * 60 * 1000)

    const description = this.generateEventDescription(session)
    const title = this.generateEventTitle(session)

    return {
      id: `studysync-${session.id}`,
      title,
      description,
      start: startDateTime.toISOString(),
      end: endDateTime.toISOString(),
      location: session.type === "study" ? "Study Location" : undefined,
      reminders: [15, 5], // 15 and 5 minutes before
    }
  }

  private generateEventTitle(session: StudySession): string {
    const prefix = session.type === "study" ? "ðŸ“š" : "âœ…"
    return `${prefix} ${session.title}`
  }

  private generateEventDescription(session: StudySession): string {
    const lines = [
      `Generated by StudySync AI`,
      `Type: ${session.type === "study" ? "Study Session" : "Personal Task"}`,
      `Priority: ${session.priority.charAt(0).toUpperCase() + session.priority.slice(1)}`,
      `Duration: ${session.duration} minutes`,
      `AI Confidence: ${Math.round(session.confidence * 100)}%`,
      "",
      `This ${session.type === "study" ? "study session" : "task"} was automatically scheduled by your AI assistant based on your calendar availability and priorities.`,
    ]

    if (session.type === "study") {
      lines.push(
        "",
        "ðŸ’¡ Study Tips:",
        "- Take breaks every 25-30 minutes",
        "- Stay hydrated",
        "- Minimize distractions",
      )
    }

    return lines.join("\n")
  }

  // Sync approved sessions to Google Calendar
  async syncSessions(sessions: StudySession[]): Promise<SyncResult> {
    const result: SyncResult = {
      success: false,
      syncedCount: 0,
      failedCount: 0,
      errors: [],
      syncedSessions: [],
    }

    // Check connection first
    const connected = await this.checkConnection()
    if (!connected) {
      result.errors.push("Not connected to Google Calendar. Please reconnect your account.")
      return result
    }

    // Simulate API calls with realistic delays
    for (const session of sessions) {
      try {
        await this.syncSingleSession(session)
        result.syncedCount++
        result.syncedSessions.push(session)
      } catch (error) {
        result.failedCount++
        result.errors.push(`Failed to sync "${session.title}": ${error.message}`)
      }
    }

    result.success = result.failedCount === 0
    return result
  }

  private async syncSingleSession(session: StudySession): Promise<void> {
    // Simulate API call delay
    await new Promise((resolve) => setTimeout(resolve, Math.random() * 1000 + 500))

    // Simulate occasional failures (5% chance)
    if (Math.random() < 0.05) {
      throw new Error("Calendar API rate limit exceeded")
    }

    const calendarEvent = this.sessionToCalendarEvent(session)

    // In a real implementation, this would make an actual Google Calendar API call
    console.log("Syncing to Google Calendar:", calendarEvent)

    // Simulate successful sync
    return Promise.resolve()
  }

  // Remove synced sessions from Google Calendar
  async removeSessions(sessionIds: number[]): Promise<SyncResult> {
    const result: SyncResult = {
      success: false,
      syncedCount: 0,
      failedCount: 0,
      errors: [],
      syncedSessions: [],
    }

    const connected = await this.checkConnection()
    if (!connected) {
      result.errors.push("Not connected to Google Calendar. Please reconnect your account.")
      return result
    }

    for (const sessionId of sessionIds) {
      try {
        await this.removeSingleSession(sessionId)
        result.syncedCount++
      } catch (error) {
        result.failedCount++
        result.errors.push(`Failed to remove session ${sessionId}: ${error.message}`)
      }
    }

    result.success = result.failedCount === 0
    return result
  }

  private async removeSingleSession(sessionId: number): Promise<void> {
    await new Promise((resolve) => setTimeout(resolve, Math.random() * 500 + 200))

    // Simulate occasional failures
    if (Math.random() < 0.03) {
      throw new Error("Session not found in calendar")
    }

    console.log("Removing from Google Calendar:", `studysync-${sessionId}`)
    return Promise.resolve()
  }

  // Get sync status for sessions
  async getSyncStatus(sessionIds: number[]): Promise<Record<number, boolean>> {
    await new Promise((resolve) => setTimeout(resolve, 300))

    const status: Record<number, boolean> = {}
    sessionIds.forEach((id) => {
      // Simulate some sessions being synced
      status[id] = Math.random() > 0.3
    })

    return status
  }

  // Batch operations for better performance
  async batchSync(sessions: StudySession[], batchSize = 5): Promise<SyncResult> {
    const result: SyncResult = {
      success: false,
      syncedCount: 0,
      failedCount: 0,
      errors: [],
      syncedSessions: [],
    }

    // Process in batches to avoid rate limits
    for (let i = 0; i < sessions.length; i += batchSize) {
      const batch = sessions.slice(i, i + batchSize)
      const batchResult = await this.syncSessions(batch)

      result.syncedCount += batchResult.syncedCount
      result.failedCount += batchResult.failedCount
      result.errors.push(...batchResult.errors)
      result.syncedSessions.push(...batchResult.syncedSessions)

      // Small delay between batches
      if (i + batchSize < sessions.length) {
        await new Promise((resolve) => setTimeout(resolve, 1000))
      }
    }

    result.success = result.failedCount === 0
    return result
  }
}

// Export singleton instance
export const calendarSync = new CalendarSyncService()
